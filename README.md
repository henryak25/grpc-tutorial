1. What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?<br>
    - Unary adalah bentuk RPC paling sederhana, di mana client mengirim satu permintaan dan server membalas dengan satu response. Metode ini cocok untuk proses cepat seperti mengambil single item dari database atau authentication user.
    - Pada server streaming, klien hanya mengirim satu permintaan, tetapi server merespons dengan mengirimkan banyak data secara bertahap dalam bentuk stream. Cocok digunakan untuk aplikasi yang memerlukan pengiriman banyak data sekaligus, seperti daftar transaksi atau hasil query besar (real time update seperti stock market prices).
    - Memungkinkan klien dan server saling bertukar banyak pesan secara simultan dalam satu koneksi. Sangat cocok untuk aplikasi real-time seperti chat atau live data monitoring, karena keduanya bisa terus berkomunikasi tanpa menunggu giliran.
2. What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?<br>
    - pada Authentication, gRPC di Rust perlu memastikan bahwa hanya klien yang sah bisa mengakses layanan. Ini bisa dilakukan dengan sertifikat TLS mutual (mTLS) atau token seperti JWT. Pastikan validasi token dilakukan dengan benar dan tepat waktu.
    - Untuk authorization, setelah autentikasi berhasil, penting untuk memeriksa apakah pengguna punya hak untuk mengakses resource tertentu. Dapat diterapkan melalui middleware yang memeriksa role/permission berdasarkan informasi dari token atau identitas pengguna.
    - Untuk data encryption, seluruh komunikasi gRPC sebaiknya dienkripsi menggunakan TLS agar data tidak bisa disadap atau dimodifikasi saat dikirim antar klien dan server. Di Rust, hal ini bisa diatur menggunakan library seperti tonic dengan konfigurasi TLS yang benar.
3. What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?<br>
    - Synchronization. Dalam streaming bidirectional, klien dan server bisa mengirim pesan kapan saja. Mengatur agar tidak terjadi race condition atau deadlock saat membaca dan menulis secara bersamaan bisa jadi sulit, apalagi di Rust yang ketat soal ownership dan borrow checker.
    - Concurrency handling. Dibutuhkan penggunaan tokio, async/await, dan task parallelism dengan benar untuk menangani banyak klien secara bersamaan tanpa blocking. Dimana jika ada kesalahan bisa menyebabkan crash.
    - Resource Management. Dalam bidirectional streaming, tiap koneksi klien biasanya membuka satu async task, buffer memory, dan channel internal. Jika tidak dikelola dengan benar, task bisa terus hidup walau klien sudah disconnect, menyebabkan memory leak dan resource exhaustion. 
4. What are the advantages and disadvantages of using the `tokio_stream::wrappers::ReceiverStream` for streaming responses in Rust gRPC services?<br>
    - Menggunakan tokio_stream::wrappers::ReceiverStream memungkinkan kita mengubah tokio::sync::mpsc::Receiver menjadi sebuah Stream, yang memang dibutuhkan oleh gRPC service untuk streaming respons ke klien. Ini sangat berguna ketika server ingin mengirim banyak pesan secara asynchronous, karena langsung terintegrasi dengan ekosistem Tokio dan mendukung penuh async/await.
5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?<br>
    - Modularize by domain. Pisahkan kode menjadi modul-modul kecil yang masing-masing bertanggung jawab atas domain tertentu. Misalnya, bisa ada modul terpisah untuk menangani layanan yang berbeda atau logika bisnis, seperti user_service, authentication, dan chat_service. Setiap modul harus terisolasi dan hanya menangani fitur atau domain tertentu.
    - Separation of Concerns. Pisahkan tanggung jawab seperti request handling, business logic, dan data storage ke dalam lapisan atau komponen yang berbeda. Dengan begitu, gRPC service handlers hanya fokus pada pengelolaan request yang masuk, sementara business logic ditempatkan di modul terpisah.
    - Implementasikan error handling dan logging secara modular, seperti menggunakan middleware untuk menangani cross-cutting concerns seperti authentication, logging, dan error responses. Dengan cara ini, error handling dapat dipusatkan dan menghindari duplikasi di masing-masing service handler.
6. In the **MyPaymentService** implementation, what additional steps might be necessary to handle more complex payment processing logic?<br>
    - Dalam implementasi MyPaymentService, ada beberapa langkah tambahan yang perlu dipertimbangkan untuk menangani logika pemrosesan pembayaran yang lebih kompleks. Pertama-tama, penting untuk memastikan bahwa pengguna telah terautentikasi dan memiliki otorisasi yang sesuai sebelum melakukan transaksi pembayaran. Selain itu, detail pembayaran perlu divalidasi untuk mencegah kesalahan input atau transaksi yang tidak sah. Penanganan error juga harus dirancang dengan baik agar sistem dapat merespons secara tepat terhadap berbagai skenario kegagalan seperti timeout. Selain itu, mencatat setiap aktivitas pembayaran ke dalam audit log juga sangat penting untuk kebutuhan pelacakan dan keamanan. 
7. What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?<br>
    - Adopsi gRPC sebagai communication protocol dapat memberikan peningkatan besar dalam performa dan efisiensi sistem terdistribusi. Dengan menggunakan HTTP/2 dan Protocol Buffers, gRPC memungkinkan komunikasi antar layanan yang lebih cepat, hemat bandwidth, serta mendukung streaming dan multiple requests secara efisien. Selain itu, gRPC bersifat language-agnostic, yang berarti layanan dalam berbagai bahasa pemrograman seperti Go, Java, atau Rust dapat saling berkomunikasi dengan mudah hanya dengan mendefinisikan service dan message menggunakan Protobuf. Namun, meskipun gRPC sangat optimal untuk komunikasi antar microservices dalam ekosistem yang seragam, interoperabilitas dengan teknologi lain—terutama yang tidak berbasis HTTP/2 atau tidak mendukung Protobuf—bisa menjadi tantangan, terutama jika dibandingkan dengan REST API yang lebih universal. Oleh karena itu, dalam desain sistem, perlu dipertimbangkan kebutuhan bridging atau gateway untuk mengakomodasi integrasi lintas platform.
8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?<br>
    - Penggunaan HTTP/2 sebagai protokol dasar untuk gRPC membawa sejumlah keunggulan dibandingkan HTTP/1.1 atau HTTP/1.1 dengan WebSocket, terutama dalam konteks komunikasi antar layanan. HTTP/2 mendukung multiplexing, yang memungkinkan banyak request dan response berjalan bersamaan dalam satu koneksi TCP tanpa saling menunggu. Hal ini meningkatkan efisiensi dan mengurangi latency, berbeda dengan HTTP/1.1 yang menggunakan model request-response secara berurutan. Selain itu, HTTP/2 mendukung header compression dan binary framing, yang membuat komunikasi lebih ringan dan cepat dibandingkan HTTP/1.1 yang berbasis teks. Namun, di sisi lain, HTTP/2 belum didukung secara merata oleh semua platform dan tools debugging, sehingga bisa menambah kompleksitas dalam pengembangan dan troubleshooting. Selain itu, tidak semua platform dan perangkat lunak mendukung HTTP/2 secara default, sehingga interoperabilitas dengan sistem lama bisa menjadi kendala. Dibandingkan dengan WebSocket yang lebih fleksibel untuk komunikasi dua arah secara real-time, HTTP/2 masih lebih cocok untuk pola RPC atau komunikasi yang bersifat structured dan service-to-service.
9. How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?<br>
    - Model request-response pada REST API bersifat synchronous dan berbasis HTTP/1.1, di mana client mengirim satu request dan harus menunggu hingga server memberikan response sebelum dapat mengirim permintaan berikutnya. Pola ini cocok untuk komunikasi yang sederhana dan stateless, namun kurang optimal untuk kebutuhan real-time karena keterbatasan dalam hal latency dan efisiensi koneksi. Sebaliknya, gRPC mendukung bidirectional streaming melalui HTTP/2, yang memungkinkan client dan server saling mengirim data secara terus-menerus dalam satu koneksi terbuka tanpa menunggu giliran. Hal ini menjadikan gRPC jauh lebih responsif dan efisien untuk aplikasi real-time seperti chat, monitoring sistem, atau streaming data. Dengan kemampuan ini, gRPC mampu menangani komunikasi dua arah dengan latensi rendah dan throughput yang lebih tinggi dibandingkan pendekatan REST tradisional.
10. What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?<br>
    - Schema based approach pada gRPC menggunakan Protocol Buffers menawarkan sejumlah keuntungan dibandingkan dengan sifat fleksibel dan tanpa schema pada payload JSON di REST API. Dengan Protobuf, struktur data didefinisikan secara eksplisit dalam service definition, yang memastikan konsistensi dalam format pesan antar sistem. Hal ini mengurangi potensi kesalahan dalam pengolahan data dan meningkatkan efisiensi dalam serialisasi dan deserialisasi data, karena Protobuf lebih kompak dan cepat dibandingkan dengan JSON. Di sisi lain, REST API dengan JSON lebih fleksibel karena tidak memerlukan schema yang kaku, memungkinkan pengembangan yang lebih cepat dan adaptasi yang lebih mudah terhadap perubahan data. Namun, fleksibilitas ini juga berisiko menambah ketidakpastian dalam kompatibilitas antar sistem, terutama dalam aplikasi besar dengan banyak integrasi. Meskipun JSON lebih mudah diintegrasikan dan lebih human-readable, Protobuf yang digunakan oleh gRPC lebih optimal untuk aplikasi yang membutuhkan performa tinggi, penghematan bandwidth, dan komunikasi antar layanan yang lebih terstruktur.